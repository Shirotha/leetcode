/*
    Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.

    An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

    Constraints:

    m == grid.length
    n == grid[i].length
    1 <= m, n <= 300
    grid[i][j] is '0' or '1'.
 */

pub struct Solution;

use std::collections::VecDeque;

struct Set {
    len: usize,
    values: Vec<usize>,
    indices: Vec<usize>,
}
impl Set {
    #[inline] fn new(len: usize) -> Self {
        Set { len, values: (0..len).collect(), indices: (0..len).collect() }
    }
    #[inline] fn contains(&self, value: usize) -> bool {
        self.indices.get(value).map_or(false, |index| index < &self.len )
    }
    #[inline] fn remove(&mut self, value: usize) -> bool {
        if self.contains(value) {
            let index = self.indices[value];
            let last = self.values[self.len - 1];
            let last_index = self.indices[last];
            self.values.swap(index, last_index);
            self.indices.swap(value, last);
            self.len -= 1;
            true
        } else { false }
    }
    #[inline] fn pop(&mut self) -> Option<usize> {
        if self.len == 0 { return None; }
        let value = self.values[0];
        self.remove(value);
        Some(value)
    }
}

impl Solution {
    pub fn num_islands(grid: Vec<Vec<char>>) -> i32 {
        let h = grid.len();
        let w = grid[0].len();
        let mut set = Set::new(w * h);
        let mut n = 0;
        let mut queue = VecDeque::new();
        while let Some(ij) = set.pop() {
            if grid[ij / w][ij % w] == '0' { continue; }
            n += 1;
            queue.push_back(ij);
            while let Some(ij) = queue.pop_front() {
                let (i, j) = (ij / w, ij % w);
                if j != 0 {
                    let left = ij - 1;
                    if set.remove(left) && grid[i][j - 1] == '1' { queue.push_back(left); }
                }
                if i != 0 {
                    let top = ij - w;
                    if set.remove(top) && grid[i - 1][j] == '1' { queue.push_back(top); }
                } 
                if j != w - 1 { 
                    let right = ij + 1;
                    if set.remove(right) && grid[i][j + 1] == '1' { queue.push_back(right); }
                }
                if i != h - 1 { 
                    let bottom = ij + w;
                    if set.remove(bottom) && grid[i + 1][j] == '1' { queue.push_back(bottom); }
                }
            }
        }
        n
    }
}

#[cfg(test)]
mod test {
    use super::*;

    fn str_to_grid(string: &str) -> Vec<Vec<char>> {
        string.split('\n').map( |line| line.chars().collect() ).collect()
    }

    /*
        Input: grid = [
        ["1","1","1","1","0"],
        ["1","1","0","1","0"],
        ["1","1","0","0","0"],
        ["0","0","0","0","0"]
        ]
        Output: 1
    */
    #[test]
    fn example1() {
        let grid = str_to_grid("\
            11110\n\
            11010\n\
            11000\n\
            00000");

        let n = Solution::num_islands(grid);

        assert_eq!(n, 1);
    }

    /*
        Input: grid = [
        ["1","1","0","0","0"],
        ["1","1","0","0","0"],
        ["0","0","1","0","0"],
        ["0","0","0","1","1"]
        ]
        Output: 3
    */
    #[test]
    fn example2() {
        let grid = str_to_grid("\
            11000\n\
            11000\n\
            00100\n\
            00011");

        let n = Solution::num_islands(grid);

        assert_eq!(n, 3);
    }

    /*
        Input: grid = [
        ["1","1","1","1","0"],
        ["1","1","0","1","0"],
        ["1","0","1","0","0"],
        ["0","0","0","0","0"]
        ]
        Output: 2
    */
    #[test]
    fn example3() {
        let grid = str_to_grid("\
            11110\n\
            11010\n\
            10100\n\
            00000");

        let n = Solution::num_islands(grid);

        assert_eq!(n, 2);
    }

    /*
        Input: grid = [
        ["1","1","1"],
        ["0","1","0"],
        ["1","1","1"]
        ]
        Output: 1
    */
    #[test]
    fn example4() {
        let grid = str_to_grid("\
            111\n\
            010\n\
            111");

        let n = Solution::num_islands(grid);

        assert_eq!(n, 1);
    }

    /*
        Input: grid = [
        ["1","1","1"],
        ["1","0","1"],
        ["1","1","1"]
        ]
        Output: 1
    */
    #[test]
    fn example5() {
        let grid = str_to_grid("\
            111\n\
            101\n\
            111");

        let n = Solution::num_islands(grid);

        assert_eq!(n, 1);
    }

    /*
        Input: grid = [
        ["1","1","1","1","1","0","1","1","1","1"],
        ["0","1","1","0","1","1","1","0","1","1"],
        ["1","0","1","0","1","1","0","1","0","1"],
        ["1","0","1","1","0","1","1","1","1","1"],
        ["1","1","0","0","1","1","1","1","1","1"],
        ["1","1","0","1","1","1","1","1","1","1"],
        ["1","1","1","1","1","1","1","1","0","1"],
        ["0","1","1","0","1","1","1","1","1","0"],
        ["1","1","0","1","1","0","1","1","1","1"],
        ["0","1","1","1","1","1","0","1","1","1"]
        ]
        Output: 1
    */
    #[test]
    fn example6() {
        let grid = str_to_grid("\
            1111101111\n\
            0110111011\n\
            1010110101\n\
            1011011111\n\
            1100111111\n\
            1101111111\n\
            1111111101\n\
            0110111110\n\
            1101101111\n\
            0111110111");

        let n = Solution::num_islands(grid);

        assert_eq!(n, 1);
    }

    /*
        Input: grid = [
        ["0","1","0"],
        ["1","0","1"],
        ["0","1","0"]
        ]
        Output: 1
    */
    #[test]
    fn example7() {
        let grid = str_to_grid("\
            010\n\
            101\n\
            010");

        let n = Solution::num_islands(grid);

        assert_eq!(n, 4);
    }

    /*
        Input: grid = [
        ["1","1","1","1","1","0","1","1","1","1","1","1","1","1","1","0","1","0","1","1"],
        ["0","1","1","1","1","1","1","1","1","1","1","1","1","0","1","1","1","1","1","0"],
        ["1","0","1","1","1","0","0","1","1","0","1","1","1","1","1","1","1","1","1","1"],
        ["1","1","1","1","0","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],
        ["1","0","0","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],
        ["1","0","1","1","1","1","1","1","0","1","1","1","0","1","1","1","0","1","1","1"],
        ["0","1","1","1","1","1","1","1","1","1","1","1","0","1","1","0","1","1","1","1"],
        ["1","1","1","1","1","1","1","1","1","1","1","1","0","1","1","1","1","0","1","1"],
        ["1","1","1","1","1","1","1","1","1","1","0","1","1","1","1","1","1","1","1","1"],
        ["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],
        ["0","1","1","1","1","1","1","1","0","1","1","1","1","1","1","1","1","1","1","1"],
        ["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],
        ["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],
        ["1","1","1","1","1","0","1","1","1","1","1","1","1","0","1","1","1","1","1","1"],
        ["1","0","1","1","1","1","1","0","1","1","1","0","1","1","1","1","0","1","1","1"],
        ["1","1","1","1","1","1","1","1","1","1","1","1","0","1","1","1","1","1","1","0"],
        ["1","1","1","1","1","1","1","1","1","1","1","1","1","0","1","1","1","1","0","0"],
        ["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],
        ["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"],
        ["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","1"]
        ]
        Output: 1
        
    */
    #[test]
    fn example8() {
        let grid = str_to_grid("\
            11111011111111101011\n\
            01111111111110111110\n\
            10111001101111111111\n\
            11110111111111111111\n\
            10011111111111111111\n\
            10111111011101110111\n\
            01111111111101101111\n\
            11111111111101111011\n\
            11111111110111111111\n\
            11111111111111111111\n\
            01111111011111111111\n\
            11111111111111111111\n\
            11111111111111111111\n\
            11111011111110111111\n\
            10111110111011110111\n\
            11111111111101111110\n\
            11111111111110111100\n\
            11111111111111111111\n\
            11111111111111111111\n\
            11111111111111111111");

        let n = Solution::num_islands(grid);

        assert_eq!(n, 1);
    }

    /*
        Input: grid = [
        ["1","0","1","1","0","0","1","0","1","1","1","1","0","1","0","1","1","1","1","0"],
        ["0","1","0","0","1","0","1","0","1","1","1","1","1","1","0","1","1","0","1","1"],
        ["1","0","0","1","0","1","0","1","0","1","1","0","1","1","1","0","0","1","1","0"],
        ["0","1","1","0","0","1","1","0","1","1","1","1","0","0","1","0","0","0","1","1"],
        ["1","1","0","1","0","0","1","0","0","0","1","0","1","0","1","1","1","0","1","1"],
        ["0","0","0","0","1","0","1","1","0","0","1","0","0","1","0","1","1","1","1","0"],
        ["1","0","1","1","1","1","0","1","1","0","1","1","0","1","1","1","0","0","1","0"],
        ["0","1","1","0","0","0","1","0","0","1","0","1","1","1","0","0","1","1","0","1"],
        ["0","0","0","0","1","1","0","1","0","0","1","1","0","1","0","0","1","0","1","0"],
        ["0","0","1","1","1","0","1","0","1","0","1","1","1","0","1","1","1","1","1","0"],
        ["1","0","1","0","1","1","1","0","1","1","1","0","1","0","1","0","1","0","1","1"],
        ["0","0","1","1","1","1","0","1","1","1","0","1","0","0","0","1","1","1","0","1"],
        ["1","1","1","0","0","0","0","0","1","1","0","1","1","1","0","1","1","1","1","0"],
        ["0","0","1","1","1","0","0","1","0","0","1","1","1","1","1","1","0","1","1","0"],
        ["0","0","0","1","1","0","0","0","0","1","1","0","1","0","0","1","1","1","1","1"],
        ["0","1","1","1","0","1","0","0","1","1","1","1","1","0","1","1","1","0","0","1"],
        ["0","0","0","0","1","1","1","1","0","0","0","0","1","0","0","0","0","1","1","0"],
        ["1","1","1","1","1","1","1","1","1","1","0","1","1","0","1","1","1","1","1","1"],
        ["0","1","0","0","1","0","0","1","1","1","1","1","1","0","1","0","1","1","1","1"],
        ["0","0","1","1","1","1","1","0","0","0","1","1","1","1","1","1","0","1","1","0"]
        ]
        Output: 23
    */
    #[test]
    fn example9() {
        let grid = str_to_grid("\
            10110010111101011110\n\
            01001010111111011011\n\
            10010101011011100110\n\
            01100110111100100011\n\
            11010010001010111011\n\
            00001011001001011110\n\
            10111101101101110010\n\
            01100010010111001101\n\
            00001101001101001010\n\
            00111010101110111110\n\
            10101110111010101011\n\
            00111101110100011101\n\
            11100000110111011110\n\
            00111001001111110110\n\
            00011000011010011111\n\
            01110100111110111001\n\
            00001111000010000110\n\
            11111111110110111111\n\
            01001001111110101111\n\
            00111110001111110110");

        let n = Solution::num_islands(grid);

        assert_eq!(n, 23);
    }
}